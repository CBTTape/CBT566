$CALL    TITLE '--  $CALL -- COMMAND TO INVOKE LINKLIST PROGRAMS.'
*  HKJ$CALL:
*
*              CHANGE RECORD:
*
*        SJB   FIX UNALLOCATION ERROR MESSAGE
*
*
*
*
*    FUNCTION: TO PROVIDE AN INTERFACE TO TRADITIONAL BATCH
*        PROGRAMS WITH STANDARD O.S. PARAMETER REQUIREMENTS
*        WITHOUT REQUIRING THE CALLER TO KNOW IN WHAT LIBRARY
*        THE CALLED PROGRAM RESIDES.  IT IS ASSUMED THAT THE
*        PROGRAM CAN BE FOUND SOMEWHERE IN THE LINK LIST
*        OR IN A LIBRARY SPECIFIED ON THE $CALL COMMAND.
*        $CALL IS ENTERED WITH AUTHORIZATION CODE OF 1.
*        IT THEN MODESETS IN SUPERVISOR STATE AND TURNS OFF
*        JSCBAUTH WHICH CHANGES THE AUTHORIZATION CODE TO ZERO.
*        IF A LIBRARY IS SPECIFIED ON THE COMMAND, THE ATTACH WILL
*        BE PERFORMED IN ROUTINE #CALL WICH IS REACHED VIA SYNCH
*        AND RUNS IN PROBLEM PROGRAM STATE.
*        IF A LIBRARY IS NOT SPECIFIED THE ATTACH WILL BE DONE IN
*        SUPERVISOR STATE WITH RSAPF=YES SPECIFIED.
*
* SYNTAX:    $CALL 'PROGRAM' 'PARAMETERS' LIB('DSLIST') CP
* REQUIRED:  'PROGRAM'
* WHERE:      'PROGRAM' - NAME OF PROGRAM TO BE ATTACHED
*              'PARAMETERS' - PARAMETERS TO BE PASSED TO PROGRAM
*                             IF CP IS SPECIFIED (SEE BELOW) THIS
*                             STRING IS ASSUMED TO BE THE REMAINDER
*                             OF THE COMMAND BUFFER FOR THE COMMAND
*                             PROCESSOR BEING ATTACHED.
*                             (LIMIT OF 100 CHARACTERS)
*              LIB('DSLIST') - LIST OF LOAD LIBRARY PDS'S TO BE
*                              USED FOR DCB IN ATTACH OF PROGRAM
*                              AND AS A TASKLIB FOR ATTACHED PROGRAM.
*                              (LIMIT OF 16)
*              CP - THE PROGRAM NAME IS A COMMAND PROCESSOR AND
*                   REQUIRES A CPPL (COMMAND PROCESSOR PARAMETER LIST)
*                   BE PASSED TO IT.
*
*
         EJECT
         MACRO
&LABEL   BADNEWS &TEXT,&THERE
         LCLC  &C
&C       SETC  '&THERE'
         AIF   ('&THERE' NE '').GO
&C       SETC  'ERRX&SYSNDX'
.GO      ANOP
&LABEL   LA    0,L'ERRM&SYSNDX
         LA    1,ERRM&SYSNDX
         TPUT  (1),(0),R
         B     &C
ERRM&SYSNDX DC C&TEXT
         AIF   ('&THERE' NE '').STOP
ERRX&SYSNDX DS 0H
.STOP    ANOP
         MEND
         EJECT
HKJ$CALL CSECT
         SPACE 2
*  REGISTER DEFINITIONS
         SPACE
RDATA    EQU   R11
RBASE    EQU   R12
RSAVE    EQU   R13
RLINK    EQU   R14
         EJECT
*  INITIALIZE AND PREPARE TO PARSE COMMAND
         SPACE
         SAVE  (14,12)
         LR    RBASE,R15
         USING HKJ$CALL,RBASE
         LR    R2,R1            CPPL ADDRESS TO R2
         USING  CPPL,R2
         GETMAIN  R,LV=DYNLEN,SP=1
         SPACE 2
*
*        CLEAR THE WORK AREA TO ALL ZEROS
*
         LR    RDATA,R1       SAVE DATA AREA ADDRESS
         USING HKJ$DATA,RDATA
         L     R14,MAXL       LOAD THE MAXIMUM LENGTH FOR XC
         BCTR  R14,0          DECREMENT THE LENGTH FOR XC
         LA    R3,DYNLEN      LOAD THE SIZE OF THE AREA
COMPARE  C     R3,MAXL        COMPARE LENGTH WITH MAXIMUM FOR XC
         BL    FINISH         BRANCH IF LESS OR EQUALE'
         EX    R14,CLEARWRK   CLEAR THE NEXT AREA
         A     R1,MAXL        INCREMENT THE STARTING ADDRESS
         S     R3,MAXL        DECREMENT THE LENGTH LEFT
         B     COMPARE        GO DO THE NEXT SEGMENT
FINISH   DS    0H
         LTR   R3,R3          IS REG 3 ZERO
         BZ    SKIPFIN        BRANCH IF SO
         BCTR  R3,0           FIX THE LENGTH FOR FINAL CLEAR
         EX    R3,CLEARWRK    FINISH THE LAST SEGMENT
         B     SKIPFIN
SKIPFIN  EQU   *
         ST    RDATA,8(RSAVE)      CHAIN SAVE AREAS
         ST    RSAVE,4(RDATA)
         LR    RSAVE,RDATA
         MVC   $CPPL+4(12),4(R2) COPY CPPL INTO WORKAREA
         LA    R1,$CBUFF      GET INTERNAL COMMAND BUFFER
         ST    R1,$CPPL       STORE IN INTERNAL CPPL
         MVC   DYNPARM,CPPLUPT  COPY PARAM POINTERS
         MVC   DYNPARM+4,CPPLECT    FROM CPPL INTO WORK AREA
         MVC   DYNATTL(ATCHLEN),ATCHMODL SET UP ATTACH WORK AREA
         LA    R0,DYNCPECB      POINT TO ECB
         ST    R0,DYNPARM+8     ALSO SAVE POINTER
         LA    R1,DYNPARM       ADDRESS PARAM LIST
         USING PPL,R1
         L     R0,PCLADDR       GET PARSE PCL POINTER
         ST    R0,PPLPCL        STORE IN PARAM LIST
         LA    R0,DYNPARSD      POINT TO ANSWER SLOT
         ST    R0,PPLANS        ALSO STORE FOR PARSE
         MVC   PPLCBUF,CPPLCBUF  COPY COMMAND BUFFER POINTER
         DROP  R1,R2
         SPACE 2
*  LINK TO PARSE ROUTINE AND ANALYZE RESULT
         SPACE
         LINK  EP=IKJPARS,MF=(E,(1))
         B     PARSCHCK(R15)
PARSCHCK DS    0H
         B     PARSEOK  00 - PARSE SUCCESSFUL
         B     NOPROMPT 04 - UNABLE TO PROMPT
         B     PARSEXT  08 - ATTENTION
         B     BADPARM  0C - INVALID PARAMS
         B     BADGMAIN 10 - NO MEMORY
         B     BADPARM  14
         B     BADPARM  18
         EJECT
*
*  PARSE SUCCESSFUL -- SET UP ENVIRONMENT AND ATTACH PROGRAM
*
         SPACE 3
PARSEOK  DS    0H
         L     R2,DYNPARSD    GET PARSE ANSWER POINTER
         USING IKJPARMD,R2
         CLI   LIBS+1,1
         BNE   NOKILLA        IF NO LIB DO NOT KILL AUTHORIZATION
         DROP  R2
*        CHECK IF AUTHORIZED
         TESTAUTH FCTN=1,STATE=YES,KEY=YES,RBLEVEL=1
         LTR   R15,R15        TEST IF AUTHORIZED
         BNZ   NOKILLA        SKIP MODESET IF NOT AUTHORIZED
*        GET SUPERVISOR STATE / KEY ZERO TO TURN OFF APF AUTHORIZATION
         SPACE 1
         MODESET MODE=SUP,KEY=ZERO
         SPACE 1
         L     R1,16          GET CVT ADDRESS
         L     R1,CVTTCBP-CVTMAP(R1) GET TCB DOUBLE WORD ADDRESS
         L     R1,4(R1)       GET CURRENT TCB ADDRESS
         L     R1,TCBJSCB-TCB(R1) GET JSCB ADDRESS
         USING IEZJSCB,R1     ADDRESS JSCB
         NI    JSCBOPTS,AUTHOFF
         DROP  R1
         SPACE 3
NOKILLA  DS    0H
         LA    R1,DYNPARM       ADDRESS PARSE PARM LIST
         USING PPL,R1
         L     R5,PPLECT
         DROP  R1
         USING ECT,R5
         L     R2,DYNPARSD    GET PARSE ANSWER POINTER
         USING IKJPARMD,R2
         CLI   CP+1,1         COMMAND PROCESSOR BEING CALLED?
         BNE   FINDPARM       LOOK FOR A PARM IF NOT CP
         MVI   $CBFCMD,C' '
         MVC   $CBFCMD+1(99),$CBFCMD
         L     R3,PROGRAM     GET CMD NAME ADDRESS
         LH    R4,PROGRAM+4   GET IT'S LENGTH
         BCTR  R4,0           CUT BY 1
         EX    R4,MOVECMD     MOVE TO CMD BUFFER
         LA    R3,8
         STH   R3,$CBFOFF     SET OFFSET
         L     R3,PARMS       GET CMD PARM ADDRESS
         LH    R4,PARMS+4     GET ITS LENGTH
         C     R4,NINE2       GREATER THAN 92
         BH    TOOLONG        BRANCH IF SO
         LTR   R4,R4            IS IT ZERO
         BZ    NOCMDPRM
         BCTR  R4,0           CUT BY 1
         EX    R4,MOVEPARM
NOCMDPRM DS    0H
         LH    R3,PARMS+4     GET PARM LENGTH AGAIN
         LA    R3,12(R3)      BUMP BY 12
         STH   R3,$CBFLEN     SET CMD BUFFER LEN
         B     ALLSET
FINDPARM DS    0H
         L     R3,PARMS         GET PARAMETER STRING POINTER
         LH    R4,PARMS+4
         LA    R0,2(,R4)
         GETMAIN  R,LV=(0)
         ST    R1,DYNPARMX      STORE PROGRAM PARM POINTER
         OI    DYNPARMX,X'80'   INDICATE END OF PARAM LIST
         STH   R4,0(,R1)        STORE LENGTH OF PARM STRING
         LTR   R4,R4            TEST FOR STRING OMITTED OR NULL
         BZ    ALLSET           SKIP STRING COPY IF SO
         C     R4,HUNDRED     GREATER THAN 100
         BH    TOOLONG
         BCTR  R4,0
         EX    R4,PARMMVC       COPY PARM STRING FOR PROGRAM
ALLSET   DS    0H
         MVC   DYNPCMD,ECTPCMD  SAVE THIS COMMAND NAME
         MVI   ECTPCMD,C' '   CLEAR PROGRAM NAME SLOT
         MVC   ECTPCMD+1(7),ECTPCMD
         L     R3,PROGRAM
         LH    R4,PROGRAM+4
         C     R4,EIGHT       GREATER THAN 8
         BH    BADNAME
         CLI   0(R3),C'$'     START WITH $
         BE    OKNAME
         CLI   0(R3),C'#'     START WITH #
         BE    OKNAME
         CLI   0(R3),C'@'     START WITH @
         BE    OKNAME
         CLI   0(R3),C'A'     LESS THAN A
         BL    BADNAME
         CLI   0(R3),C'Z'     GREATER THAN Z
         BH    BADNAME
OKNAME   DS    0H
         BCTR  R4,0
         EX    R4,PROGMVC
         CLI   LIBS+1,1       WAS A LIB LIST SPECIFIEC
         BE    SETLIB         GO SET UP THE TASKLIB IF SO
         EJECT
CHECKCP  DS    0H
         CLI   CP+1,1         COMMAND PROCESSOR BEING CALLED?
         BNE   NOTCP          SKIP IF NOT
         LA    R1,$CPPL       LOAD CPPL POINTER FOR CP.
         B     YESCP
NOTCP    DS    0H
         LA    R1,DYNPARMX      SET UP PARM LIST POINTER
YESCP    DS    0H
         CLI   LIBS+1,1       WAS A LIBLIST SPECIFIED
         BNE   NOTASK         SKIP IT NOT
         LA    R2,ECTPCMD       POINT TO PROGRAM NAME
         ST    R2,PEPLOC
         ST    R1,PARMHOLD    SAVE PARM REG
         LR    R1,RDATA       LOAD POINTER TO WORK AREA
         L     R15,V#CALL     LOAD ADDRESS OF #CALL ROUTINE
         SYNCH (15)           GO TO #CALL TO DO ATTACH
         B     EXTRETRN       BRANCH AROUND INTERNAL ATTACH
NOTASK   DS    0H
         LA    R2,ECTPCMD       POINT TO PROGRAM NAME
         LA    R3,DYNRETN       POINT TO NEW TASK ECB
         XR    R4,R4            CLEAR DCB REG
         ATTACH  EPLOC=(2),ECB=(3),MF=(E,(1)),SF=(E,DYNATTL),DCB=(4),  X
               TASKLIB=(4)      RSAPF=YES
         ST    R1,DYNATCB        SAVE ATTATCHED TCB POINTER
         WAIT  ECB=(3)           WAIT FOR TASK TO TERMINATE
         LA    R1,DYNATCB        POINT TO TCB ADDRESS
         DETACH  (1)             RELEASE USER TASK
EXTRETRN DS    0H
         L     R2,DYNPARSD    RELOAD PARSE ANSWER POINTER
         MVC   ECTPCMD,DYNPCMD   CHANGE COMMAND NAME BACK
         CLI   CP+1,1         WAS IT A CP
         BE    NOPARMF        IF SO NO PARM AREA TO FREE
         L     R1,DYNPARMX       RETREIVE USER PARM POINTER
         LH    R4,0(R1)          GET LENGTH OF PARM FIELD
         LA    R0,2(,R4)         ADD LENGTH TO STRING LENGTH
         FREEMAIN  R,LV=(0),A=(1)    RELEASE PARM FIELD
NOPARMF  DS    0H
         CLI   LIBS+1,1       WAS THERE A TASKLIB
         BNE   HKJ$EXIT       SKIP IF NOT
         SPACE 3
         B     DROPLIBS       GO DROP THE LIBRARY
         SPACE 3
*  EXIT ROUTINES
         SPACE
PARSEXT  ST    R15,DYNRETN   STORE RETURN CODE
HKJ$EXIT IKJRLSA DYNPARSD
         L     R2,DYNRETN    LOAD RETURN CODE
         LR    R1,RSAVE
         L     RSAVE,4(RSAVE) BACK UP SAVE CHAIN
         FREEMAIN  R,LV=DYNLEN,A=(1),SP=1
         LR    15,R2         SET RETURN CODE REGISTER
         RETURN  (14,12),RC=(15)
         EJECT
*
*        SET UP THE TASKLIB FROM THE LIST OF DATA SETS
*
         SPACE 3
SETLIB   DS    0H
*
*        INITIALIZE THE WORK AREA USING DATA MODELS
*
         SPACE 3
         MVC   TASKDA08,DA08MODL INITIALIZE THE DAIR PARAMETER BLOCKS
         MVC   TASKDA0C,DA0CMODL
         MVC   TASKDA10,DA10MODL
         MVC   TASKDA18,DA18MODL
         LA    R1,TASKDSNB    GET ADDRESS OF DSNAME BUFFER
         ST    R1,DA08PDSN    STORE IN DAIR ALLOCATION BLOCK
         SPACE 2
*        INITIALIZE THE DAIR PARAMETER LIST
         MVC   DAPLUPT,$CPPL+4  MOVE IN UPT ADDRESS
         MVC   DAPLECT,$CPPL+12 MOVE IN ECT ADDRESS
         MVC   DAPLPSCB,$CPPL+8  MVE IN PSCB ADDRESS
         LA    R1,TASKECB     PICK ECB ADDRS
         ST    R1,DAPLECB     STORE IN DAPL
         SPACE 2
*        INITIALIZE THE DAIRFAIL PARM LIST
         LA    R1,TASKJF02    GET ADDRESS OF ZERO HOLDER
         ST    R1,DFJEFF02    STORE IN DAIRFAIL PARM LIST
         SPACE 2
*        INITIALIZE THE MACRO REMOTE PARAMETER LIST
         MVC   TASKOPEN,OPENMODL INITIALIZE THE OPEN PARAMETER LIST
         MVC   TASKLINK,LINKMODL INITIALIZE THE LINK PARAMETER LIST
         MVC   TASKDCB,DCBMODL   INITIALIZE THE DCB
         SPACE 2
         LA    R1,LIBLISTX    GET ADDRS OF FIRST DSNAME PDE
         ST    R1,NEXTDSN     STORE IN WORK AREA
         EJECT
*
*        PICK UP DATA SET NAMES
*
         SPACE 3
NEXTDS   DS    0H
         L     R7,NEXTDSN     PICK UP NEXT DSN PDE ADDRS
         LA    R7,0(R7)       CLEAR HI-ORDER BYTE
         LTR   R7,R7          CHECK FOR END OF LIST
         BZ    EODLIST        BRANCH IF SO
         LH    R1,DA0CNUMB    PICK UP # OF DATA SETS
         LA    R1,1(R1)       BUMP IT
         CH    R1,=H'16'      GREATER THAN 16
         BH    TOOMANY
         STH   R1,DA0CNUMB    STORE IT BACK
         L     R0,24(R7)      PICK UP NEXT DSN PDE POINTER
         ST    R0,NEXTDSN     STORE IT FOR LATER
         L     R1,0(R7)       PICK UP DSN ADDRS
         LH    R15,4(R7)     PICK UP DSN LENGTH
         STH   R15,DSNLEN    STORE IN CASE OF NO ADDITIONS
         MVC   DSNAME,BLANKS  CLEAR THE DSNAME BUFFER
         BCTR  R15,0         DECR LENGTH FOR EXECUTED INST
         EX    R15,MOVEDSN   MOVE THE DSNAME TO BUFFER
         SPACE 2
*
*        THE DATA SET NAME MUST NOW BE QUALIFIED WITH '.LOAD' IF
*        THE FOLLOWING CONDITIONS ARE MET:
*             1. THE DATA SET NAME WAS NOT ENTERED IN QUOTES.
*             2. THE DATA SET NAME ENTERED IS NOT 'LOAD'.
*             3. IT IS NOT ALLREADY QUALIFIED WITH '.LOAD'.
*
         SPACE 1
         TM    6(R7),X'40'    WAS IT QUOTED?
         BO    ALLOCATE       BRANCH IF SO
         LA    R1,DSNAME      GET DSNAME ADDRESS
         LR    R14,R1         SAVE IT
QBMPLOOP DS    0H             LOOP TO COUNT OFF PREFIX
         CLI   0(R1),C'.'     END OF PREFIX?
         BE    OUTBMP         BRANCH IF SO
         LA    R1,1(R1)       INCREMENT TO NEXT CHARACTER
         B     QBMPLOOP       GO EXAMINE NEXT CHARACTER
MOVEDSN  MVC   DSNAME(R15),0(R1) (EXECUTED DATA SET NAME MOVER)
OUTBMP   DS    0H
         LA    R1,1(R1)       BUMP PAST PERIOD
         LR    R3,R1          SAVE PAST PREFIX ADDRESS
         SR    R1,R14         COMPUTE PREFIX LENGTH
         LH    R15,DSNLEN     LOAD DSNAME LENGTH
         SR    R15,R1         COMPUTE UN-PREFIXED LENGTH
         CH    R15,=H'4'     RIGHT LENGTH FOR 'LOAD'
         BL    QUALIFY        NO - TO SHORT, GO QUALIFY
         BH    CHECKQ         NO - GO CHECK FOR QUALIFIER
         CLC   0(4,R3),=C'LOAD' IS IT 'LOAD'
         BNE   QUALIFY        NO - GO TO DO QUALIFY
         B     ALLOCATE       DSNAME IS 'LOAD', GO DO ALLOCATION
CHECKQ   DS    0H
         S     R15,=F'5'     EXAMINE QUALIFIER IF PRESENT
         BNP   QUALIFY        IF TOO SHORT THEN NEEDS QUALIFIER!
         AR    R3,R15        POINT TO LAST 5 CHARACTERS IN NAME
         CLC   0(5,R3),=C'.LOAD' IS QUALIFIER LOAD?
         BE    ALLOCATE
QUALIFY  DS    0H
         LH    R15,DSNLEN    RELOAD LENGTH
         CH    R15,=Y(44-5)  WILL QUALIFIER FIT?
         BE    ALLOCATE       TRY ASIS IF NOT
         LA    R1,DSNAME(R15) POINT TO END
         MVC   0(5,R1),=C'.LOAD' APPEND QUALIFIER
         LA    R15,5(R15)   INCREMENT LENGTH
         STH   R15,DSNLEN    STORE IN DSNAME BUFFER
         XC    TASKECB,TASKECB CLEAR THE ECB
*
*        ALLOCATE THE DATA SET
*
ALLOCATE DS    0H
         LA    R1,TASKDA08
         ST    R1,DAPLDAPB    STORE ALLOCATION BLOCK ADDRS IN DAPL
         CALLTSSR EP=IKJDAIR,MF=(E,TASKDAPL) CALL DAIR TO ALLOCATE
         LTR   R15,R15      TEST RETURN CODE
         BZ    DAIROK01       SKIP BRANCH TO DAIRFAIL
         BAL   RLINK,DAIREROR GO HANDLE DAIR ERROR
         LA    R15,12
         B     PARSEXT
DAIROK01 DS    0H
         CLI   DA08DSO,X'02'  MAKE SURE IT'S PARTITIONED
         BNE   BADDSORG
         SPACE 2
*
*        PICK UP DDNAME AND OPEN THE DATA SET
*        TO CHECK THE RECORD FORMAT (MUST BE U)
*
         LA    R3,TASKDCB
         USING IHADCB,R3      ADDRESS DCB
         MVC   DCBDDNAM,DA08DDN MOVE DDNAME TO DCB
         OPEN  ((3),INPUT),MF=(E,TASKOPEN) OPEN THE DATA SET
         TM    DCBOFLGS,DCBOFOPN CHECK OPEN FOR SUCCESSFUL
         BZ    BADOPEN
         CLI   DCBRECFM,X'C0' MAKE SURE IT'S RECFM=U
         BNE   BADRECFM       BRANCH IF NOT
         CLOSE ((3)),MF=(E,TASKOPEN) CLOSE THE DATA SET
         DROP  R3
         EJECT
*
*        SAVE DDNAME AND BLANK IT OUT IN DA08 BLOCK
*
         SPACE 3
         LH    R15,DA0CNUMB  PICK UP DATA SET COUNT
         BCTR  R15,0         DROP BY 1
         SLL   R15,3         SHIFT LEFT BY 3 TO MULTIPLY BY 8
         LA    R1,DA0CDDN     PICK UP FIRST DDNAME PLACE ADDRS
         AR    R1,R15        OFFSET TO NEXT BLANK ONE
         MVC   0(8,R1),DA08DDN MOVE IN DDNAME FROM ALLOCATION BLOCK
         MVC   DA08DDN,BLANKS BLANK OUT DDNAME IN BLOCK
         LTR   R15,R15        FIRST DDNAME?
         BNZ   NEXTDS
         MVC   DA10DDN,0(R1)  SAVE FIRST DDNAME IN DECONCAT BLOCK
         B     NEXTDS         GO DO THE NEXT DATA SET
         EJECT
*
*        ALL DATA SETS HAVE BEEN CHECKED AND ALLOCATED.
*        NOW CONCATENATE THEM UNDER DDNAME TASKLIB.
*
         SPACE 3
EODLIST  DS    0H
         CLC   DA0CNUMB,=H'1' IF ONLY 1 DS SKIP CONCATENATION.
         BE    DOOPEN
         XC    TASKECB,TASKECB CLEAR THE ECB
         LA    R1,TASKDA0C    GET ADDRESS OF DAIR CONCATENATION BLOCK
         ST    R1,DAPLDAPB STORE IN PARM LIST
         CALLTSSR EP=IKJDAIR,MF=(E,TASKDAPL) CALL DAIR
         LTR   R15,R15
         BZ    DOOPEN         SKIP DAIRFAIL IF GOOD
         BAL   RLINK,DAIREROR
         B     HKJ$EXIT
         EJECT
*
*        OPEN THE TASKLIB DCB
*
         SPACE 3
DOOPEN   DS    0H
         LA    R3,TASKDCB     GET ADDRESS OF DCB
         USING IHADCB,R3      ADDRESS IT
         MVC   DCBDDNAM,DA0CDDN MOVE DDNAME FROM CONCAT BLOCK
*        OPEN THE TASKLIB DCB
         OPEN ((3),INPUT),MF=(E,TASKOPEN)
         TM    DCBOFLGS,DCBOFOPN TEST THE OPEN
         BZ    BADTASK
         B     CHECKCP
         DROP  R3
         EJECT
*
*        FREE THE TASKLIB DATASET LIST
*
         SPACE 3
DROPLIBS DS    0H
         CLOSE (TASKDCB),MF=(E,TASKOPEN)
         CLC   DA0CNUMB,=H'1' IF ONLY 1 SKIP DECONCATENATION
         BE    DEALCOLD
         XC    TASKECB,TASKECB
         LA    R1,TASKDA10    LOAD ADDRESS OF DECONCAT BLOCK
         ST    R1,DAPLDAPB    STORE IN DAIR PARM LIST
         CALLTSSR EP=IKJDAIR,MF=(E,TASKDAPL) CALL DAIR
         LTR   R15,R15      CHECK RETURN CODE
         BZ    DEALCOLD       SKIP IF GOOD
         BAL   RLINK,DAIREROR GO HANDLE THE ERROR
         B     HKJ$EXIT
         EJECT
*
*        DEALLOCATE THE OLD DATA SET LIST
*
DEALCOLD DS    0H
         LA    R15,12
         LH    R4,DA0CNUMB    PICK UP NUMBER OF DDNAMES
         LA    R3,DA0CDDN     PICK UP ADDRESS OF FIRST DDNAME
         LA    R1,TASKDA18    PICK UP ADDRESS OF DEALLOCATION BLOCK
         ST    R1,DAPLDAPB    STORE IN DAIR PARM LIST
         SPACE 3
DOLDLOOP DS    0H
         XC    TASKECB,TASKECB CLEAR THE ECB
         MVC   DA18DDN,0(R3)  MOVE IN DDNAME
         LA    R3,8(R3)       POINT AT NEXT DDNAME (IF ANY)
         CALLTSSR EP=IKJDAIR,MF=(E,TASKDAPL) CALL DAIR
         LTR   R15,R15        CHECK RETURN CODE
         BNZ   DODAIRER       GO DO DAIR ERROR THING
         TM    DA18FLG,X'80'  TEST FLAG BIT IN DAPB
         BNO   GOODUNAL
DODAIRER DS    0H
         BAL   RLINK,DAIREROR
GOODUNAL DS    0H
         BCT   R4,DOLDLOOP    GO DO THE NEXT DDNAME                 SJB
         B     HKJ$EXIT
         EJECT
*
*        BEGIN ERROR ROUTINES
*
         SPACE 3
         PRINT NOGEN
*        INVALID PARSE PARAMETERS
         SPACE 1
BADPARM  BADNEWS 'INVALID PARSE PARAMETERS SPECIFIED'
         LA    R15,12
         B     PARSEXT
         SPACE 3
*        UNABLE TO PROMPT USER
         SPACE 1
NOPROMPT BADNEWS 'UNABLE TO PROMPT.  $CALL ABORTED.'
         LA    R15,12
         B     PARSEXT
         SPACE 3
*        PARM TOO LONG
         SPACE 1
TOOLONG  BADNEWS 'PARM SPECIFIED IS TOO LONG.  $CALL ABORTED.'
         LA    R15,12
         B     PARSEXT
         SPACE 3
*        INVALID MODULE NAME
         SPACE 1
BADNAME  BADNEWS 'INVALID PROGRAM NAME SPECIFIED.'
         LA    R15,12
         B     PARSEXT
         SPACE 3
*        NO CORE FOR PARSE.
         SPACE 1
BADGMAIN BADNEWS 'NOT ENOUGH CORE FOR PARSE.'
         LA    R15,12
         B     PARSEXT
         SPACE 3
*        TOO MANY DATA SETS SPECIFIED.
         SPACE 1
TOOMANY  BADNEWS 'TOO MANY DATA SETS SPECIFIED.  COMMAND IGNORED.'
FREEALL  DS    0H             FREE THE ALLOCATED DATA SETS
         LH    R3,DA0CNUMB    PICK UP NUMBER OF DDNAMES
         LA    R3,DA0CDDN     PICK UP ADDRESS OF FIRST DDNAME
         LA    R1,TASKDA18    PICK UP ADDRESS OF DEALLOCATION BLOCK
         ST    R1,DAPLDAPB    STORE IN DAIR PARM LIST
FREELOOP DS    0H
         XC    TASKECB,TASKECB CLEAR THE ECB
         MVC   DA18DDN,0(R3)  MOVE IN DDNAME
         LA    R3,8(R3)       POINT AT NEXT DDNAME (IF ANY)
         CALLTSSR EP=IKJDAIR,MF=(E,TASKDAPL) CALL DAIR
         BCT   R4,FREELOOP    GO DO THE NEXT DDNAME
         LA    R15,12
         B     PARSEXT
         SPACE 3
*        BAD OPEN DURING DATA SET CHECKOUT
         SPACE 1
BADOPEN  BADNEWS 'OPEN FAILURE.  $CALL ABORTED.'
         LA    R15,12
         B     PARSEXT
         SPACE 3
*        INVALID DATA SET ORGANIZATION
         SPACE 1
BADDSORG BADNEWS 'DATA SET IS NOT PARTITIONED.  $CALL ABORTED.'
         B     FREEALL
         SPACE 3
*        INVALID RECORD FORMAT
         SPACE 1
BADRECFM BADNEWS 'DATA SET IS NOT RECORD FORMAT U.  $CALL ABORTED.'
         CLOSE ((3)),MF=(E,TASKOPEN) CLOSE THE DATA SET
         B     FREEALL
         SPACE 3
*        BAD OPEN FOR TASKLIB DCB PROPER.
         SPACE 1
BADTASK  BADNEWS 'OPEN FAILURE FOR TASKLIB.  $CALL ABORTED.'
         CLC   DA0CNUMB,=H'1' IF ONLY 1 SKIP DECONCATENATION
         BE    FREEALL
         XC    TASKECB,TASKECB
         LA    R1,TASKDA10    LOAD ADDRESS OF DECONCAT BLOCK
         ST    R1,DAPLDAPB    STORE IN DAIR PARM LIST
         CALLTSSR EP=IKJDAIR,MF=(E,TASKDAPL) CALL DAIR
         LTR   R15,R15      CHECK RETURN CODE
         BNZ   DAIREROR       BRANCH IF ERROR
         B     FREEALL
         PRINT GEN
         EJECT
*
*        DAIR ERROR ROUTINE
*
         SPACE 3
DAIREROR DS    0H
*        INITIALIZE THE DAIRFAIL PARM LIST
         LA    R1,TASKDFRC    GET ADDRESS OF RETURN CODE HOLDER
         ST    R1,DFRCP       STORE IN DAIRFAIL PARM LIST
         LA    R1,TASKDAPL    GET ADDRESS OF DAIR PARM LIST
         ST    R1,DFDAPLP     STORE INTO DAIR FAIL PARM LIST
         ST    R15,TASKDFRC   STORE RETURN CODE IN DAIRFAIL RC HOLDER
         LA    R1,DFSWITCH    PICK UP ADDRESS OF SWITCH BYTES
         ST    R1,DFIDP       STORE IN DAIRFAIL PARM LIST
         LINK EP=IKJEFF18,MF=(E,TASKDFPL),SF=(E,TASKLINK)
         SPACE 3
         BR    RLINK          RETURN TO CALLER
         EJECT
*
*   PARSE VALIDITY CHECK FOR DSNAMES
*
         SPACE 3
DSNCHECK DS    0H
         USING DSNCHECK,R15
         L     R1,0(,R1)           LOAD PDE ADDR
         TM    6(R1),X'80'         MAKE SURE NAME IS PRESENT
         BZ    DSNBAD
         SLR   R15,R15
         BR    R14
DSNBAD   LA    R15,4
         BR    R14
         DROP  R15
         EJECT
*
*        EXECUTED INSTRUCTIONS AND CONSTANTS.
*
         SPACE 3
CLEARWRK XC    0(0,R1),0(R1)
MAXL     DC    F'256'
HUNDRED  DC    F'100'
NINE2    DC    F'92'
EIGHT    DC    F'8'
BLANKS   DC    CL80' '
DFSWITCH DC    X'0001'        DAIRFAIL SWITCH BYTES
PCLADDR  DC    V(HKJ$PCL)
PROGMVC  MVC   ECTPCMD(0),0(R3)
PARMMVC  MVC   2(0,R1),0(R3)
MOVECMD  MVC   $CBFCMD(0),0(R3)
MOVEPARM MVC   $CBFPARM(0),0(R3)
V#CALL   DC    V(HKJ#CALL)
AUTHOFF  EQU   B'11111110'
         EJECT
*
*        DATA MODELS
*
         SPACE 3
         PRINT NOGEN
DA08MODL DC    AL2(8,0,0,0),A(0),CL24' '
         DC    4A(0),CL16' ',4AL1(8),AL3(0),X'00',CL8' '
DA08MLEN EQU   *-DA08MODL
         SPACE 2
DA0CMODL DC    AL2(12,0,0,0,0,0),CL128' '
DA0CMLEN EQU   *-DA0CMODL
         SPACE 2
DA10MODL DC    AL2(16,0,0,0),CL8' '
DA10MLEN EQU   *-DA10MODL
         SPACE 2
DA18MODL DC    AL2(24,0,0,0),A(0),CL18' ',AL1(0,16),A(0,0)
DA18MLEN EQU   *-DA18MODL
         SPACE 2
OPENMODL OPEN (,INPUT),MF=L
OPENLEN  EQU   *-OPENMODL
         SPACE 2
DCBMODL  DCB   DDNAME=TASKLIB,MACRF=R,DSORG=PO,BLKSIZE=19069
DCBLEN   EQU   *-DCBMODL
LINKMODL LINK ,SF=L
LINKLEN  EQU   *-LINKMODL
ATCHMODL ATTACH SHSPV=78,SF=L
ATCHLEN  EQU   *-LINKMODL
         LTORG
         EJECT
*  HKJ#CALL:
*
*    FUNCTION: TO PROVIDE A MEANS OF ATTACHING PROGRAMS FROM
*        USER LIBRARIES WITHOUT ABENDING WITH A 306-C.
*        THIS MODULE PERFORMS ONLY THE ATTACH.  ALL OTHER WORK
*        IS DONE BY $CALL (HKJ$CALL).
*        NOTE: THIS MODULE IS ENTERED VIA SYNCH AND RUNS IN
*              PROBLEM PROGRAM STATE.
*        WHEN CONTROL IS RECIEVED FROM $CALL THE APF BIT
*        IN THE JSCBOPTS FIELD HAS BEEN TURNED OFF BY $CALL
*        THUS THIS MODULE FUNCTIONS AS NON AUTHORIZED EVEN THOUGH
*        IT IS LINK-EDITED WITH HKJ$CALL UNDER AN APF OF 1.
*
HKJ#CALL CSECT
*  INITIALIZE AND PREPARE TO PERFORM ATTACH
         SPACE
         SAVE  (14,12)
         LR    RBASE,R15
         USING HKJ#CALL,RBASE
         LR    RDATA,R1       ADDRESS WORK AREA
         USING HKJ$DATA,RDATA
         SPACE 3
*        CHAIN SAVE AREAS
         LA    R1,SAVE2       GET ADDRESS OF SECOND LOAD SAVE AREA
         ST    R1,8(RSAVE)    BACK CHAIN
         ST    RSAVE,4(R1)    FORWARD CHAIN
         LR    RSAVE,R1       LOAD NEW SAVE AREA POINTER
*        SETUP FOR THE ATTACH
         SPACE 3
         L     R1,PARMHOLD    GET PARM REG
         LA    R4,TASKDCB     GET ADDRESS OF DCB (ALLREADY OPEN)
         L     R2,PEPLOC        POINT TO PROGRAM NAME
         LA    R3,DYNRETN       POINT TO NEW TASK ECB
         ATTACH  EPLOC=(2),ECB=(3),MF=(E,(1)),SF=(E,DYNATTL),          X
               DCB=(4),TASKLIB=(4)     ,RSAPF=YES
         ST    R1,DYNATCB        SAVE ATTATCHED TCB POINTER
         WAIT  ECB=(3)           WAIT FOR TASK TO TERMINATE
         LA    R1,DYNATCB        POINT TO TCB ADDRESS
         DETACH  (1)             RELEASE USER TASK
         L     R13,4(R13)    BACK UP SAVE CHAIN
         RETURN  (14,12),RC=(15)
         EJECT
HKJ$PCL  IKJPARM
PROGRAM  IKJIDENT  'PROGRAM NAME',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM,C
               PROMPT='PROGRAM NAME',                                  C
               HELP='NAME OF PROGRAM TO BE CALLED'
PARMS    IKJPOSIT  QSTRING,                                            C
               HELP='PARAMETERS TO BE PASSED TO THE CALLED PROGRAM'
CP       IKJKEYWD
         IKJNAME 'CP'
LIBS     IKJKEYWD
         IKJNAME 'LIB',SUBFLD=LIBLIST
LIBLIST  IKJSUBF
LIBLISTX IKJPOSIT DSNAME,LIST,USID,VALIDCK=DSNCHECK,                   X
               PROMPT='DATA SET NAME(S)',                              X
               HELP=('NAME OF DATA SET(S) TO BE USED AS A TASKLIB')
         IKJENDP
         EJECT
*  DYNAMIC WORK AREA MAPPING
         SPACE
HKJ$DATA DSECT
SAVE1    DS    18F                 SAVE AREA FOR $CALL
SAVE2    DS    18F                 SAVE AREA FOR #CALL
DYNPARM  DS    7F
DYNPARMX DS    F
DYNCPECB DS    F
DYNPARSD DS    F
DYNRETN  DS    F
DYNATCB  DS    F
PARMHOLD DS    F
PEPLOC   DS    F
$CPPL    DS    4F             CP CPPL
#ECB     DS    F              #CALL ECB FOR ATTACH
#TCB     DS    F              #CALL TCB HOLDER FOR ATTACH
$CBUFF   DS    0CL104
$CBFLEN  DS    CL2
$CBFOFF  DS    CL2
$CBFCMD  DS    CL8
$CBFPARM DS    CL92
DYNATTL  ATTACH  SHSPV=78,SF=L
DYNPCMD  DS    CL8
DYNBUFF  DS    CL24
         DS    0D
         SPACE 2
TASKDCB  DS    CL(DCBLEN)     DCB FOR TASKLIB
         SPACE 2
TASKDA08 DS    0CL(DA08MLEN)  DAIR ALLOCATION BLOCK
DA08CD   DS    X'0008'
DA08FLG  DS    CL2
DA08DARC DS    CL2
DA08CTRC DS    CL2
DA08PDSN DS    A(0)
DA08DDN  DS    CL8' '
DA08UNIT DS    CL8' '
DA08SER  DS    CL8' '
DA08BLK  DS    A(0)
DA08PQTY DS    A(0)
DA08SQTY DS    A(0)
DA08DQTY DS    A(0)
DA08MNM  DS    CL8' '
DA08PDSW DS    CL8' '
DA08DSP1 DS    X'08'          SHR
DA08DSP2 DS    X'08'          KEEP
DA08DSP3 DS    X'08'          KEEP
DA08CTL  DS    X'08'          FULLY QUALIFIED
         DS    X'000000'      RESERVED
DA08DSO  DS    X'00'          MUST BE X'02' AFTER ALLOCATION
DA08ALN  DS    CL8' '
DA08LEN  EQU   *-TASKDA08
         SPACE 2
         DS    0F             ALIGN TO FULL WORD
TASKDA0C DS    0CL(DA0CMLEN)  DAIR CONCANTENATION BLOCK
DA0CCD   DS    X'000C'
DA0CFLG  DS    CL2
DA0CDARC DS    CL2
         DS    X'0000'        RESERVED
DA0CNUMB DS    CL2            NUMBER OF DDNAMES (DATA SETS)
         DS    X'0000'        RESERVED
DA0CDDN  DS    16CL8' '       DDNAME LIST
DA0CLEN  EQU   *-TASKDA0C
         SPACE 2
         DS    0F             ALIGN TO FULL WORD
TASKDA10 DS    0CL(DA10MLEN)  DAIR DECONCATENATION BLOCK
DA10DC   DS    X'0010'
DA10FLG  DS    CL2
DA10DARC DS    CL2
         DS    X'0000'        RESERVED
DA10DDN  DS    CL8'TASKLIB '
DA10LEN  EQU   *-TASKDA10
         SPACE 2
         DS    0F             ALIGN TO FULL WORD
TASKDA18 DS    0CL(DA18MLEN)  DAIR DEALLOCATION (FREEING) BLOCK
DA18CD   DS    X'0018'
DA18FLG  DS    CL2
DA18DARC DS    CL2
DA18CTRC DS    CL2
DA18PDSN DS    A(0)
DA18DDN  DS    CL8' '
DA18MNM  DS    CL8' '
DA18SCLS DS    CL2' '
DA18DSP2 DS    X'08'          KEEP
DA18CTL  DS    X'10'
         DS    A(0,0)         RESERVED
DA18LEN  EQU   *-TASKDA18
         SPACE 2
         DS    0F             ALIGN TO FULL WORD
TASKOPEN DS    CL(OPENLEN)
TASKLINK DS    CL(LINKLEN)
         SPACE 2
TASKECB  DS    F              TASK ECB
NEXTDSN  DS    F              NEXT DATA SET PDE POINTER
         SPACE 2
TASKDAPL DS    0CL20          DAIR PARAMETER LIST
DAPLUPT  DS    A
DAPLECT  DS    A
DAPLECB  DS    A
DAPLPSCB DS    A
DAPLDAPB DS    A
         SPACE 2
DAPLLEN  EQU   *-TASKDAPL
         SPACE 2
TASKDFPL DS    0CL16          DAIRFAIL PARAMETER LIST
DFDAPLP  DS    A
DFRCP    DS    A
DFJEFF02 DS    A
DFIDP    DS    A
DFPLLEN  EQU   *-TASKDFPL
         SPACE 2
         DS    0F
TASKDSNB DS    0CL46          DSNAME BUFFER
DSNLEN   DS    H              DSNAME LENGTH
DSNAME   DS    CL44           DSNAME PROPER
         SPACE 1
TASKDFRC DS    A              DAIRFAIL RETURN CODE HOLDER
TASKJF02 DS    A              DUMMY ADDRESS (ALLWAYS ZERO)
         SPACE 2
DYNLEN   EQU   *-HKJ$DATA
         SPACE 5
         IKJCPPL
         SPACE 5
         IKJPPL
         SPACE 5
         IKJECT
         SPACE 5
         CVT   DSECT=YES
         SPACE 5
         IKJTCB
         SPACE 5
         IEZJSCB
         SPACE 5
         DCBD  DEVD=DA,DSORG=PO
         SPACE 5
         YREGS ,
         END
